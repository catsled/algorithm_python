

不使用循环语句在一个列表中找到最大值和最小值
(递归方法)
1.设置函数结束标志:当列表长度小于等于0时返回结果.

2.设置比较方法:设置一个初始值(-1),依次与列表中的每一个值作比较,如果条件满足,则修改结果值.

3.若比较条件不满足,那么,初始值不变,列表位置加1.

由于是尾递归,所以直接返回结果即可.

def find_min_max(s,result):
    if (len(s)) == 0:
        return result
    else:
        if result[0] < s[0]:
            result[0] = s[0]
        if result[1] > s[0]:
            result[1] = s[0]
        return find_min_max(s[1:],result)

-----------------------------------------------------------------------------------

只用除法和加法计算log2#n(不计算小数以及负数部分)

1.设置程序结束标志:log2#1 = 0
2.程序每除一次2则结果加1

def loga(n):
    if n == 1:
        return 0
    else:
        return 1 + loga(n // 2)


------------------------------------------------------------------------------------

只用加法和减法计算两个数的乘积

考虑到:乘法就是将一个数加n次得到的结果,所以: n*m = m个n相加

1.设置程序结束:当m为0时,返回0

2.否则程序返回n+product(n,m-1)

def product(n,m):
    if m == 0:
        return 0
    else:
        return n + product(m-1)

------------------------------------------------------------------------------------

使用递归方法将一个输入字符串反转

1.设置函数结束标志:当字符串的起始位置大于或等与结束位置,则证明该字符串的元素个数为1或0

2.将字符串中的元素首尾交换

def reverse_s(s,start,end):
    if start >= end:
        return 1
    else:
        s[start],s[end] = s[end],s[start]
        reverse_s(s,start+1,end-1)

------------------------------------------------------------------------------------

使用递归方法判断一个字符串是否是回文:

1.设置函数结束标志:当字符串的起始位置大于或等与结束位置时,函数返回值为真

2.将字符串中的元素首尾比较,如果相同则继续进行比较,否则返回假

def palindrome(n,start,end):
    if start >= end:
        return True
    else:
        if n[start] == n[end]:
            return palindrome(n,start+1,end-1)
        else:
            return False

------------------------------------------------------------------------------------

判断一个字符串中元音字母出现的次数是否比普通的字母出现的次数多

1.设置函数结束标志:设置一个容器,当容器中的元音字母个数大于字符串长度的一半时,则返回True

2.当字符串长度为零时,且条件1没有触发,则返回False

3.判断当前字符是否是元音字母,如果是元音字母则加入容器,函数进行递归操作


def more_vowel(s,v,start):
    if len(v) > len(s) // 2:
        return True
    if len(s[start:]) <= 0:
        return False
    else:
        if s[start] in ('a','e','i','o','u'):
            v.append(s[start])
        return more_vowel(s,v,start+1)

------------------------------------------------------------------------------------

输入一列数字,将所有偶数都排在奇数前面

1.设置函数结束标志:当字符串的起始位置大于或等与结束位置时,函数返回值为真

2.如果第一个数字是奇数,最后一个是偶数,那么交换两者,并且数列的起始位置加1,结束位置减1；
  如果第一个数字是奇数,最后一个也是奇数,那么将结束位置减1;
  如果第一个数字是偶数,最后一个也是偶数,那么将起始位置加1;
  否则的话将起始位置加1,结束位置不变.

  def odd_before(n,start,end):
      if start >= end:
          return True
      else:
          if n[start] % 2 != 0 and n[end] % 2 == 0:
              n[start],n[end] = n[end],n[start]
              odd_before(n,start+1,end-1)
          elif n[start] % 2 != 0 and n[end] % 2 != 0:
              odd_before(n,start,end-1)
          elif n[start] % 2 == 0 and n[end] % 2 == 0:
              odd_before(n,start+1,end)
          else:
              odd_before(n,start+1,end)

-----------------------------------------------------------------------------------

给定一个k值和一个列表,将列表中所有大于k值的数排在小于k值的数的前面.

1.设定函数结束标志:当列表的长度小于等于0时,函数返回结果列表

2.当列表中的第一个值小于k值的时候,将该值加入到临时列表b中,并把该值从列表中删除,继续该操作.
  当列表中的第一个值大于k值的时候,将该值加入到临时列表a中,并把该值从列表中删除,继续该操作.

def before_k(n,k,b,a):
    if len(n) <= 0:
        return a+b
    else:
        if n[0] < k:
            b.append(n[0])
            n.remove(n[0])
            before_k(n,k,b,a)
        else:
            a.append(n[0])
            n.remove(n[0])
            before_k(n,k,b,a)
------------------------------------------------------------------------------------

给定一个k值和一个集合,判断集合中是否有两个数之和的值是k

1.设定函数结束条件:当两数之和为k

2.取大小为2的子集,计算子集之和,若子集的大小不符合条件则继续计算

def sum_k(n,k,s,u):
    for value in u:
        s.append(value)
        u.remove(value)
        if n == 1 and sum(s) == k:
            print(s,k)
        else:
            sum_k(n-1,k,s,u)
        u.add(s.pop())

------------------------------------------------------------------------------------


递归:就是在运行中调用自己、

递归在计算机中的实现推测：

当在一个函数内调用另一个函数时,程序控制流会转到被调用函数的位置,并同时保存调用函数的信息,
当被调用函数运行完后,控制流会转到调用函数的记录点,从记录点开始继续按顺序执行程序.

同样的当一个函数调用自己时,计算机会像对待调用其他函数一样处理.

-----------------------------------------------------------------------------------

首先通过一个简单的阶乘函数来看一看递归函数怎么用:

5! = 5*4*3*2*1
5! = 5*4!

可以得到:

n! = n*(n-1)!
0! = 1

一般的如果按照普通的方法去实现这个功能:

def factorial_n(n):
    value = 1
    for i in range(n,0,-1):
        value *= i
    return value

按照递归的定义:

def factorial_r(n):
    if n == 0:
        return 1
    else:
        return n*factorial_r(n-1)

两者所实现的功能是一样的,但是递归版清楚地按照数学公式来实现,更加易懂.
------------------------------------------------------------------------------------

现在来利用递归函数实现汉诺塔的玩法:(分治)

首先汉诺塔的规则是:有三个柱子,现在在其中一根柱子上有n个圆盘,按照从大到小的顺序向上排列,
                现在要求,将所有的圆盘从某根柱子上移动到另一根柱子上且每次移动时,小圆盘必须
                在大圆盘上面或者在一根空柱子上.

可以这样想:当有0个圆盘时:不需要移动;当有一个圆盘时:只需要直接将圆盘移动到目的地;当有两个圆盘时:
         可以先将小圆盘移动到中转的柱子上,然后再将大圆盘移动到目的地,最后再将小圆盘移动到大圆
         盘上;当有三个圆盘时,只需先将两个较小的圆盘移动到中转的柱子上然后再将大圆盘移动至目的
         地,最后再将中转柱子上的圆盘移动至大圆盘上.(最后移动中转柱子的时候可以将中转柱子上看作
         是初始柱子)

由此可以推断出:
            move(n) = 0 : 0
            move(n) = 2*move(n-1) + 1 : n>0

1:计算移动次数

total = [0]
def move(n): #n代表有几个圆盘
    if n == 0:
        return 0
    else:
        move(n-1)
        total[0] += 1
        move(n-1)

2:显示移动轨迹

def move(n,z1,z2,z3): #z1,z2,z3分别代表第一个柱子,...
    if n == 1:
        print(z1,'-->',z3)
    else:
        move(n-1,z1,z3,z2)  #将除了最大盘都移动到中转柱子上
        move(1,z1,z2,z3) #将最大盘移动到目标柱子上
        move(n-1,z2,z1,z3) #将中转柱子上的圆盘都移动到目标柱子

------------------------------------------------------------------------------------

为了进一步了解递归的实际作用,现在来学习一下二分搜索(分治)

二分搜索:在一个排序过的数组里寻找指定的数据,数组被一个中间值分为两个部分.
       搜索被分为三种情况:
       1.特定值 == 中间值:寻找成功
       2.特定值  < 中间值:去较小的数组里寻找
       3.特定值  > 中间值:去较大的数组里寻找

       当数组的起始位置(low) > 数组结束位置(high)时:数组为空,寻找结束

       假设: a_list是一个排好序的数组(长度>1)
       中间值: mid = low + high // 2,虽然中间值可能无法平均分配数组,但是依旧可以保证每个元素都可以取到

       def binary_search(array,target,low,high):
           if low > high:
               print('查找失败')
               return False
           mid = (low+high) // 2
           if target == array[mid]:
               print('查找成功')
               return True
           if target < array[mid]:
               binary_search(array,target,low,mid-1)
           else:
               binary_search(array,target,mid+1,high)

-----------------------------------------------------------------------------------





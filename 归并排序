归并排序的分析,实现

---------------------------------------------------------------------------
分析:

    输入:一组任意顺序的数据
    输出:一组按照指定方式排列的数据
    存储方式: 列表

过程:
	划分:
	1.初始条件:如果列表中只有一个元素,那么列表不需要划分.
	2.假设:如果列表中有K个元素,可以通过每次将原规模缩小为原来的一半,最后可以将该列表分为k个列表.
	3.推断:如果列表中有k+1个元素,也可以通过每次将原规模缩小为原来的一半,最后可以将该列表分为k+1个列表

	证明:因为k个元素可以正确划分,所以当有k+1个元素的时候,在划分的时候,会有一个列表中的元素个数多与另外一个列表,但是在分到最后的时候,都要分成只有一个元素的列表,所以并不会影响.
---------------------------------------------------------------------------
实现:

	def merge_sort(N):
		n = len(N)
		if n <= 1:
			return N
		mid = n // 2
		left = merge_sort(N[:mid])
		right = merge_sort(N[mid:])
		return merge(left,right)

	def merge(left,right):
		result = list()
		i = 0
		j = 0
		while i < len(left) and j < len(right):
			if N[i] < N[j]:
				result.append(N[i])
				i += 1
			else:
				result.append(N[j])
				j += 1
		result += N[i:]
		result += N[j:]
		return result 

---------------------------------------------------------------------------
时间复杂度:
			O(nlogn)

